---
// Performance optimization component for Core Web Vitals and loading speed
export interface PerformanceOptimizationProps {
  criticalResources?: string[];
  preloadImages?: string[];
  enableServiceWorker?: boolean;
}

const {
  criticalResources = [],
  preloadImages = [],
  enableServiceWorker = false
} = Astro.props as PerformanceOptimizationProps;
---

<!-- Critical Resource Preloading -->
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link rel="dns-prefetch" href="//fonts.googleapis.com" />

<!-- Preload critical CSS and JS -->
{criticalResources.map(resource => (
  <link rel="preload" href={resource} as={resource.endsWith('.css') ? 'style' : 'script'} crossorigin />
))}

<!-- Preload critical images -->
{preloadImages.map(image => (
  <link rel="preload" href={image} as="image" />
))}

<!-- Service Worker for caching (optional) -->
{enableServiceWorker && (
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => console.log('SW registered'))
          .catch(error => console.log('SW registration failed'));
      });
    }
  </script>
)}

<!-- Performance monitoring script -->
<script>
  // Core Web Vitals monitoring
  function sendMetric(name, value) {
    // You can send this data to your analytics service
    console.log(`${name}: ${value}`);
  }

  // Largest Contentful Paint
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];
    sendMetric('LCP', lastEntry.startTime);
  }).observe({entryTypes: ['largest-contentful-paint']});

  // First Input Delay
  new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      sendMetric('FID', entry.processingStart - entry.startTime);
    }
  }).observe({entryTypes: ['first-input']});

  // Cumulative Layout Shift
  let cumulativeLayoutShiftScore = 0;
  new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (!entry.hadRecentInput) {
        cumulativeLayoutShiftScore += entry.value;
      }
    }
    sendMetric('CLS', cumulativeLayoutShiftScore);
  }).observe({entryTypes: ['layout-shift']});

  // Page load optimization
  window.addEventListener('load', () => {
    // Lazy load images that are not critical
    const lazyImages = document.querySelectorAll('img[loading="lazy"]');
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src || img.src;
            img.classList.add('loaded');
            observer.unobserve(img);
          }
        });
      });
      lazyImages.forEach(img => imageObserver.observe(img));
    }
  });
</script>

<!-- Resource hints for better performance -->
<meta name="format-detection" content="telephone=no" />
<meta http-equiv="x-dns-prefetch-control" content="on" />

<!-- Prevent render blocking -->
<style>
  /* Critical CSS for preventing layout shift */
  img { opacity: 1; transition: opacity 0.3s ease; }
  img[loading="lazy"] { opacity: 0; }
  img[loading="lazy"].loaded { opacity: 1; }
  
  /* Prevent cumulative layout shift for images */
  img { 
    height: auto; 
    width: 100%; 
    aspect-ratio: attr(width) / attr(height);
  }
</style>
