---
// Analytics component for privacy-friendly tracking
const { 
  enableAnalytics = true,
  trackingId = null,
  enableErrorTracking = true 
} = Astro.props;
---

{enableAnalytics && (
  <script>
    // Privacy-friendly analytics implementation
    class EverdantiaAnalytics {
      constructor() {
        this.sessionId = this.generateSessionId();
        this.visitorId = this.getOrCreateVisitorId();
        this.startTime = Date.now();
        this.events = [];
        this.init();
      }

      generateSessionId() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      }

      getOrCreateVisitorId() {
        // Get existing visitor ID or create new one (persists across sessions)
        let visitorId = localStorage.getItem('everdantia_visitor_id');
        if (!visitorId) {
          visitorId = 'v_' + Math.random().toString(36).substring(2, 15) + '_' + Date.now().toString(36);
          localStorage.setItem('everdantia_visitor_id', visitorId);
          localStorage.setItem('everdantia_first_visit', Date.now().toString());
        }
        return visitorId;
      }

      init() {
        // Track page views
        this.trackPageView();
        
        // Track user interactions
        this.setupEventListeners();
        
        // Track performance metrics
        this.trackPerformance();
        
        // Track errors if enabled
        if (window.enableErrorTracking) {
          this.setupErrorTracking();
        }
      }

      trackPageView() {
        const isFirstVisit = !localStorage.getItem('everdantia_has_visited');
        if (isFirstVisit) {
          localStorage.setItem('everdantia_has_visited', 'true');
        }

        const data = {
          type: 'pageview',
          url: window.location.pathname,
          referrer: document.referrer,
          timestamp: Date.now(),
          sessionId: this.sessionId,
          visitorId: this.visitorId,
          isFirstVisit: isFirstVisit,
          userAgent: navigator.userAgent,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        };
        
        this.sendEvent(data);
      }

      trackEvent(eventName, properties = {}) {
        const data = {
          type: 'event',
          name: eventName,
          properties,
          url: window.location.pathname,
          timestamp: Date.now(),
          sessionId: this.sessionId,
          visitorId: this.visitorId
        };
        
        this.sendEvent(data);
      }

      trackPerformance() {
        // Track Core Web Vitals
        if ('web-vital' in window) {
          // This would integrate with a web vitals library
          return;
        }

        // Basic performance tracking
        window.addEventListener('load', () => {
          const perfData = performance.getEntriesByType('navigation')[0];
          const data = {
            type: 'performance',
            metrics: {
              domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
              loadComplete: perfData.loadEventEnd - perfData.loadEventStart,
              firstPaint: this.getFirstPaint(),
              timeToInteractive: this.estimateTimeToInteractive()
            },
            url: window.location.pathname,
            timestamp: Date.now(),
            sessionId: this.sessionId
          };
          
          this.sendEvent(data);
        });
      }

      getFirstPaint() {
        const paintEntries = performance.getEntriesByType('paint');
        const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');
        return firstPaint ? firstPaint.startTime : null;
      }

      estimateTimeToInteractive() {
        // Simple TTI estimation
        return performance.now();
      }

      setupEventListeners() {
        // Track clicks on important elements
        document.addEventListener('click', (e) => {
          const target = e.target.closest('a, button, [data-track]');
          if (target) {
            const eventName = target.dataset.track || this.getElementDescription(target);
            this.trackEvent('click', {
              element: eventName,
              href: target.href || null,
              text: target.textContent?.trim().substring(0, 100)
            });
          }
        });

        // Track form submissions
        document.addEventListener('submit', (e) => {
          const form = e.target;
          this.trackEvent('form_submit', {
            formId: form.id || 'unknown',
            action: form.action || window.location.href
          });
        });

        // Track scroll depth
        let maxScroll = 0;
        const trackScroll = () => {
          const scrollPercent = Math.round(
            (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100
          );
          if (scrollPercent > maxScroll) {
            maxScroll = scrollPercent;
            if (scrollPercent >= 25 && scrollPercent < 50) {
              this.trackEvent('scroll_depth', { depth: '25%' });
            } else if (scrollPercent >= 50 && scrollPercent < 75) {
              this.trackEvent('scroll_depth', { depth: '50%' });
            } else if (scrollPercent >= 75 && scrollPercent < 90) {
              this.trackEvent('scroll_depth', { depth: '75%' });
            } else if (scrollPercent >= 90) {
              this.trackEvent('scroll_depth', { depth: '90%' });
            }
          }
        };

        let scrollTimeout;
        window.addEventListener('scroll', () => {
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(trackScroll, 100);
        });
      }

      getElementDescription(element) {
        if (element.dataset.track) return element.dataset.track;
        if (element.id) return `#${element.id}`;
        if (element.className) return `.${element.className.split(' ')[0]}`;
        return element.tagName.toLowerCase();
      }

      setupErrorTracking() {
        window.addEventListener('error', (e) => {
          this.trackEvent('javascript_error', {
            message: e.message,
            filename: e.filename,
            lineno: e.lineno,
            colno: e.colno,
            stack: e.error?.stack?.substring(0, 1000)
          });
        });

        window.addEventListener('unhandledrejection', (e) => {
          this.trackEvent('promise_rejection', {
            reason: e.reason?.toString?.()?.substring(0, 500) || 'Unknown error'
          });
        });
      }

      sendEvent(data) {
        // Store locally for offline capability
        if (typeof window !== 'undefined') {
          const events = JSON.parse(localStorage.getItem('everdantia_analytics') || '[]');
          events.push(data);
          // Keep only last 100 events to prevent storage overflow
          if (events.length > 100) {
            events.splice(0, events.length - 100);
          }
          localStorage.setItem('everdantia_analytics', JSON.stringify(events));
          
          // Send to analytics API endpoint with retry logic
          this.sendToAPI(data, 3); // Try up to 3 times
        }
      }

      async sendToAPI(data, retries = 3) {
        for (let attempt = 1; attempt <= retries; attempt++) {
          try {
            const response = await fetch('/api/analytics', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(data)
            });

            if (response.ok) {
              // Success - mark this event as synced if needed
              if (window.location.hostname === 'localhost') {
                console.log('✅ Analytics event sent successfully');
              }
              return;
            } else {
              throw new Error(`API returned ${response.status}: ${response.statusText}`);
            }
          } catch (error) {
            if (window.location.hostname === 'localhost') {
              console.warn(`❌ Analytics attempt ${attempt}/${retries} failed:`, error.message);
            }
            
            if (attempt === retries) {
              // Final attempt failed - store for later retry
              this.storeFailed(data);
              if (window.location.hostname === 'localhost') {
                console.error('💥 Analytics failed after all retries, stored for later');
              }
            } else {
              // Wait before retry (exponential backoff)
              await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
          }
        }
      }

      storeFailed(data) {
        // Store failed events for later retry
        const failed = JSON.parse(localStorage.getItem('everdantia_analytics_failed') || '[]');
        failed.push({...data, failedAt: Date.now()});
        if (failed.length > 50) {
          failed.splice(0, failed.length - 50); // Keep last 50 failed events
        }
        localStorage.setItem('everdantia_analytics_failed', JSON.stringify(failed));
      }

      // Method to retry failed events
      async retryFailedEvents() {
        const failed = JSON.parse(localStorage.getItem('everdantia_analytics_failed') || '[]');
        if (failed.length === 0) return;

        const toRetry = [...failed];
        localStorage.removeItem('everdantia_analytics_failed'); // Clear the queue

        for (const event of toRetry) {
          await this.sendToAPI(event, 1); // Single retry attempt
          await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between requests
        }
      }

      // Method to get analytics data (for debugging)
      getStoredEvents() {
        return JSON.parse(localStorage.getItem('everdantia_analytics') || '[]');
      }

      // Method to get failed events (for debugging)
      getFailedEvents() {
        return JSON.parse(localStorage.getItem('everdantia_analytics_failed') || '[]');
      }

      // Method to clear analytics data
      clearStoredEvents() {
        localStorage.removeItem('everdantia_analytics');
        localStorage.removeItem('everdantia_analytics_failed');
      }

      // Method to get sync status
      getSyncStatus() {
        const stored = this.getStoredEvents().length;
        const failed = this.getFailedEvents().length;
        return {
          totalStored: stored,
          totalFailed: failed,
          syncRate: stored > 0 ? ((stored - failed) / stored * 100).toFixed(1) + '%' : '100%'
        };
      }
    }

    // Initialize analytics
    window.enableErrorTracking = true;
    window.everdantiaAnalytics = new EverdantiaAnalytics();

    // Retry failed events when page loads
    setTimeout(() => {
      window.everdantiaAnalytics?.retryFailedEvents();
    }, 2000); // Wait 2 seconds for page to fully load

    // Expose tracking method globally for manual event tracking
    window.trackEvent = (name, properties) => {
      window.everdantiaAnalytics?.trackEvent(name, properties);
    };

    // Console helper for debugging (remove in production)
    if (window.location.hostname === 'localhost' || window.location.hostname.includes('dev')) {
      console.log('🌿 Everdantia Analytics initialized');
      console.log('Use window.everdantiaAnalytics.getStoredEvents() to view tracked events');
      console.log('Use window.everdantiaAnalytics.getFailedEvents() to view failed events');
      console.log('Use window.everdantiaAnalytics.getSyncStatus() to check sync status');
      console.log('Use window.everdantiaAnalytics.retryFailedEvents() to retry failed events');
      console.log('Use window.trackEvent("event_name", {prop: "value"}) to track custom events');
    }
  </script>
)}

<script>
  // Performance monitoring for Core Web Vitals
  function measureWebVitals() {
    // Cumulative Layout Shift (CLS)
    let clsValue = 0;
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
      // Track CLS when page visibility changes or on page unload
      if (clsValue > 0) {
        window.trackEvent?.('web_vital_cls', { value: clsValue });
      }
    }).observe({ type: 'layout-shift', buffered: true });

    // Largest Contentful Paint (LCP)
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      const lastEntry = entries[entries.length - 1];
      window.trackEvent?.('web_vital_lcp', { value: lastEntry.startTime });
    }).observe({ type: 'largest-contentful-paint', buffered: true });

    // First Input Delay (FID)
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        window.trackEvent?.('web_vital_fid', { 
          value: entry.processingStart - entry.startTime 
        });
      }
    }).observe({ type: 'first-input', buffered: true });
  }

  // Initialize web vitals measurement when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', measureWebVitals);
  } else {
    measureWebVitals();
  }
</script>
